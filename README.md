# backtrace
---
 通过objdump -d 命令可以查看反汇编指令  
 反汇编出来后如下：  
 00000079 <B>:  
  79:   55                      push   %ebp  
  7a:   89 e5                   mov    %esp,%ebp  
  7c:   8b 45 0c                mov    0xc(%ebp),%eax  
  7f:   03 45 08                add    0x8(%ebp),%eax  
  82:   5d                      pop    %ebp  
  83:   c3                      ret  
  
00000084 <A>:  
  84:   55                      push   %ebp  
  85:   89 e5                   mov    %esp,%ebp  
  87:   83 ec 18                sub    $0x18,%esp  
  8a:   c7 45 fc ff 00 00 00    movl   $0xff,-0x4(%ebp)  
  91:   c7 45 f8 ff ff 00 00    movl   $0xffff,-0x8(%ebp)  
  98:   8b 45 f8                mov    -0x8(%ebp),%eax  
  9b:   89 44 24 04             mov    %eax,0x4(%esp)  
  9f:   8b 45 fc                mov    -0x4(%ebp),%eax  
  a2:   89 04 24                mov    %eax,(%esp)  
  a5:   e8 fc ff ff ff          call   a6 <A+0x22>  
  aa:   c9                      leave  
  ab:   c3                      ret  
   
从上面反汇编可以看出，在A调用B时，A的调用栈布局信息如下，  
高地址:  |---------|  
         |   ebp   |<--|  push   %ebp  -------------A-----------------  
         |---------|   |  
         |   c     |   |  movl   $0xff,-0x4(%ebp)   ;A函数局部变量 c  
         |---------|   |  
         |   d     |   |  movl   $0xffff,-0x8(%ebp) ;A函数局部变量 d  
         |---------|   |  
         |         |   |  
         |---------|   |  
         |         |   |  
         |---------|   |  
  c+%ebp|   d     |   |  mov    %eax,0x4(%esp)    ;A调用B函数时，准备好参数d  
         |---------|   |  
  8+%ebp|   c     |   |  mov    %eax,(%esp)       ;A调用B函数时，准备好参数c  
         |---------|   |<----%esp      -------------A----------------  
  4+%ebp| retaddr |   | A 调用B的返回地址，在执行call指令时，指令自动把call指令下一条压入这个地方。  
         |---------|   |  
  %ebp->|  ebp    |---  对应于执行B函数 :push %ebp时，把在A函数运行时的ebp保存到该位置中。  
         |---------|  
 ---
低地址:
后面B在执行mov    0xc(%ebp),%eax时，简单用语言描述一下函数调用过程，就那上A调用B来说，首先A函数准备好参数，即把局部变量c，d放到栈上，然后执行call B(call   a6 <A+0x22>)指令，call指令执行时默认会把当前指令的下一条指令压入栈中，然后执行B函数第一条指令即（push %ebp)，所以当执行到B函数push %ebp时，栈的信息就是上面那种样子了。  知道一般程序是怎么压栈的，并且A函数调用B函数会把A函数中调用B函数的那条call指令的下一条指令压栈栈中，通常情况一个函数第一条指令都是push  
 %ebp, 功能是保存调用函数栈帧，第2条指令时mov %esp , %ebp，即把esp赋值给ebp，即初始化当前函数栈帧。  在执行过程中，函数调用首先指向call执行，然后执行被调用者第一条指令(push %ebp)，c语言函数调用通常都是这样情况的，而call指令又一个隐藏动作就是把下一指令（返回地址）压栈。所以在栈里面排布就是
 ---
 | ret_addr|  
 |---------|   
 |   ebp   |    
 |---------|   
           
我们再看一下第二条指令，mov %esp , %ebp ， 初始化当前函数栈帧。最终结果如下  
  ---------  
 | ret_addr|   |  
 |---------|   |  
 |    ebp  |---/     
 |---------|<--|  
 |   ...   |   |  
 |---------|   |  
 | ret_addr|   |  
 |---------|   |  
 |  ebp    |---/  
 |---------|<--|   
 |  ...    |   |  
 |---------|   |           
 | ret_addr|   |  
 |---------|   |  
 |   ebp   |---/  
 |---------|---|
 ---
所以我们只要知道当前%epb的值，就可以通过上面那种图示方法进行调用栈分析了。有人会问为什么libc有函数实现了，自己就没有必要了，但libc只提供获取当前线程的调用栈信息，有些时候需要获取其他线程的调用栈信息，这个时候就需要自己分析实现了，总体思路一样，只需要获取到其它线程的%ebp信息即可，但通常情况在用户态是不能够获取%ebp寄存器的，可以借助内存模块来实现。 
一种方法使用libc库里面backtrace函数实现，还有一种就是自己通过分析调用栈信息来实现
